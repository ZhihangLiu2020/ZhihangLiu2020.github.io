(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{524:function(_,v,l){"use strict";l.r(v);var i=l(1),a=Object(i.a)({},(function(){var _=this,v=_.$createElement,l=_._self._c||v;return l("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[l("h2",{attrs:{id:"加密算法"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#加密算法"}},[_._v("#")]),_._v(" 加密算法")]),_._v(" "),l("p",[_._v("哈希算法：用来确保数据没有被篡改。")]),_._v(" "),l("p",[_._v("密钥交换算法：用来确保密钥的交换，一般是使双方协商出用于加密报文内容的对称密钥。有DH，RSA等")]),_._v(" "),l("p",[_._v("对称加密：加解密使用相同的密钥。")]),_._v(" "),l("p",[_._v("非对称加密：有公钥和私钥之分，公钥公开，私钥只有自己知道。")]),_._v(" "),l("p",[_._v("在实际应用中，对称加密和非对称加密是同时使用的：")]),_._v(" "),l("ul",[l("li",[_._v("非对称加密用来保证双方安全的获得对称密钥")]),_._v(" "),l("li",[_._v("对称加密用来加密数据")])]),_._v(" "),l("p",[_._v("签名：A使用自己的私钥加密一份数据，这个过程叫签名。因为只有A有自己的私钥，其他人只要用A的公钥对该数据进行解密，就可以知道此数据到底是不是A发送的，并且A也无法否认，因此叫签名。")]),_._v(" "),l("p",[_._v("数字证书：这个东西是由认证机构（CA）颁发给服务器的，服务器可以用来证明身份的一份数据。它包括该服务器信息和CA的签名。")]),_._v(" "),l("p",[_._v("需要知道的是，CA的公钥被提前内置在了操作系统和浏览器中，默认我们是信任操作系统的，也就信任其中内置的CA公钥。")]),_._v(" "),l("p",[_._v("数字证书的工作原理：")]),_._v(" "),l("ol",[l("li",[_._v("服务器S把自己的信息(包括自己的公钥)发给CA，CA对服务器S的所有信息使用哈希算法得到一个值hash_A，然后用自己的私钥对hash_A进行加密(签名)，最后把服务器S的信息和自己的签名放到一起，叫做数字证书。")]),_._v(" "),l("li",[_._v("每当服务器S需要证明自己身份时，就把数字证书发给客户C，C从操作系统中取出CA的公钥，对数字证书上CA的签名进行解密得到了hash_A这个结果，然后用同样的哈希算法对数字证书上服务器S的信息进行计算，得到hash_B，对比两个hash值，就知道了服务器S到底是不是真的S。")]),_._v(" "),l("li",[_._v("到此数字证书的作用就生效了。另外，操作系统中内置的往往是根CA，而给服务器S发证书的CA不一定是根CA，有可能是根CA信任的下一级CA，这就存在一个证书链。因此客户C验证S的证书时，实际上是先向CA确认给S颁发证书的CA的身份，然后再用该CA的公钥去验证服务器S的身份。信任是从上向下传递过去的。")])]),_._v(" "),l("h2",{attrs:{id:"tls协议"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#tls协议"}},[_._v("#")]),_._v(" TLS协议")]),_._v(" "),l("p",[_._v("TLS协议流程，图片来自公众号：小林coding")]),_._v(" "),l("p",[l("img",{attrs:{src:"/imgs/image-20210727221654067.png",alt:"image-20210727221654067"}})]),_._v(" "),l("p",[_._v("首选3次握手建立TCP连接，然后是TLS4次握手协商出密钥，最后是发送http请求和接收响应。其中TLS握手阶段，协商密钥可以使用RSA算法，也可以使用DH算法。")]),_._v(" "),l("h2",{attrs:{id:"_1-概览"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#_1-概览"}},[_._v("#")]),_._v(" 1 概览")]),_._v(" "),l("p",[_._v("这本教材主要讲了四部分内容，分别为：")]),_._v(" "),l("ul",[l("li",[_._v("密码算法\n"),l("ul",[l("li",[_._v("对称密码")]),_._v(" "),l("li",[_._v("非对称密码")]),_._v(" "),l("li",[_._v("hash函数和数字签名")])])]),_._v(" "),l("li",[_._v("相互信任\n"),l("ul",[l("li",[_._v("用户身份认证问题")]),_._v(" "),l("li",[_._v("密钥分配和管理问题")])])]),_._v(" "),l("li",[_._v("网络安全\n"),l("ul",[l("li",[_._v("如何将密码算法用于网络协议和应用。")])])]),_._v(" "),l("li",[_._v("计算机安全\n"),l("ul",[l("li",[_._v("主要是恶意软件和网络入侵")])])])]),_._v(" "),l("p",[_._v("1.1 计算机安全概念")]),_._v(" "),l("p",[_._v("对称加密：可以加密任意大小的数据块。")]),_._v(" "),l("p",[_._v("非对称加密：主要用于加密较小的数据块。比如用于给"),l("code",[_._v("加密密钥")]),_._v("加密。")]),_._v(" "),l("p",[_._v("计算机安全五目标：")]),_._v(" "),l("ul",[l("li",[_._v("保密性")]),_._v(" "),l("li",[_._v("完整性")]),_._v(" "),l("li",[_._v("可用性")]),_._v(" "),l("li",[_._v("真实性")]),_._v(" "),l("li",[_._v("可追溯性")])]),_._v(" "),l("p",[_._v("1.2 OSI安全框架")]),_._v(" "),l("p",[_._v("国际电信联盟推荐方案X.800给出的OSI安全框架：")]),_._v(" "),l("ul",[l("li",[_._v("安全攻击")]),_._v(" "),l("li",[_._v("安全服务")]),_._v(" "),l("li",[_._v("安全机制")])]),_._v(" "),l("p",[_._v("1.3 安全攻击")]),_._v(" "),l("p",[_._v("1.3.1 被动攻击")]),_._v(" "),l("p",[_._v("对传输进行窃听和检测。包括 信息内容泄漏 和 流量分析。")]),_._v(" "),l("p",[_._v("1.3.2 主动攻击")]),_._v(" "),l("p",[_._v("对消息流进行修改和伪造。包括伪装，重播，消息修改和拒绝服务。")]),_._v(" "),l("p",[_._v("1.4 安全服务")]),_._v(" "),l("p",[_._v("X.800定义：安全服务是由协议层提供的，分为5类14个服务：")]),_._v(" "),l("ul",[l("li",[_._v("认证")]),_._v(" "),l("li",[_._v("访问控制")]),_._v(" "),l("li",[_._v("数据保密性")]),_._v(" "),l("li",[_._v("数据完整性")]),_._v(" "),l("li",[_._v("不可否认性")])]),_._v(" "),l("p",[_._v("1.5 安全机制")]),_._v(" "),l("p",[_._v("X.800规定的安全机制分为两类，一类是在协议层实现的（TCP/应用层），另一类是不属于任何协议层的（加密）。")]),_._v(" "),l("ul",[l("li",[_._v("加密")]),_._v(" "),l("li",[_._v("数字签名")]),_._v(" "),l("li",[_._v("访问控制")]),_._v(" "),l("li",[_._v("数据完整性")]),_._v(" "),l("li",[_._v("流量填充")]),_._v(" "),l("li",[_._v("路由控制")]),_._v(" "),l("li",[_._v("公证")]),_._v(" "),l("li",[_._v("事件监测")]),_._v(" "),l("li",[_._v("安全审计跟踪")]),_._v(" "),l("li",[_._v("...")])]),_._v(" "),l("h2",{attrs:{id:"_2-传统加密技术"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#_2-传统加密技术"}},[_._v("#")]),_._v(" 2 传统加密技术")]),_._v(" "),l("p",[_._v("2.1 对称密码模型")]),_._v(" "),l("p",[l("code",[_._v("Y=E(K,X)")])]),_._v(" "),l("p",[l("code",[_._v("X=D(K,Y)")])]),_._v(" "),l("p",[_._v("使用要求：")]),_._v(" "),l("ul",[l("li",[_._v("加密算法必须足够强")]),_._v(" "),l("li",[_._v("密钥必须安全传输和保存")])]),_._v(" "),l("p",[_._v("2.1.1 密码编码学")]),_._v(" "),l("ul",[l("li",[_._v("明-密转换运算类型。包括代替和置换（重新排列），是可逆运算，")]),_._v(" "),l("li",[_._v("所用的密钥数。对称密码和非对称密码。")]),_._v(" "),l("li",[_._v("处理明文的方法。")])]),_._v(" "),l("p",[_._v("2.1.2 密码分析学和穷举攻击")]),_._v(" "),l("ul",[l("li",[_._v("唯密文攻击")]),_._v(" "),l("li",[_._v("已知明文攻击")]),_._v(" "),l("li",[_._v("选择明文攻击")]),_._v(" "),l("li",[_._v("...")])]),_._v(" "),l("p",[_._v("2.2 代替技术")]),_._v(" "),l("ul",[l("li",[_._v("Caesar密码")]),_._v(" "),l("li",[_._v("单表代替密码")]),_._v(" "),l("li",[_._v("Playfair密码")]),_._v(" "),l("li",[_._v("Hill密码")]),_._v(" "),l("li",[_._v("多表代替密码")]),_._v(" "),l("li",[_._v("一次一密")])]),_._v(" "),l("p",[_._v("2.3 置换技术")]),_._v(" "),l("p",[_._v("2.4 转轮机")]),_._v(" "),l("p",[_._v("2.5 隐写术")]),_._v(" "),l("h2",{attrs:{id:"_3-分组密码和数据加密标准"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#_3-分组密码和数据加密标准"}},[_._v("#")]),_._v(" 3 分组密码和数据加密标准")]),_._v(" "),l("p",[_._v("数据加密标准DES，高级加密标准AES")]),_._v(" "),l("h2",{attrs:{id:"_4-数论和有限域"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#_4-数论和有限域"}},[_._v("#")]),_._v(" 4 数论和有限域")])])}),[],!1,null,null,null);v.default=a.exports}}]);